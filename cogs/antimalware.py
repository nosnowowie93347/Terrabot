import logging, yaml
import typing as t
from typing import List
from os.path import splitext
from collections import defaultdict
from discord import Embed, Message, NotFound
from discord.ext.commands import Cog, Bot


log = logging.getLogger(__name__)

PY_EMBED_DESCRIPTION = (
    "It looks like you tried to attach a Python file - "
    f"please use a code-pasting service "
)
EXE_EMBED_DESCRIPTION = (
    "It looks like you tried to attach an EXE file - "
    f"We don't allow those here, as they may contain malware. Please use google drive instead. "
)

TXT_EMBED_DESCRIPTION = (
    "**Uh-oh!** It looks like your message got zapped by our spam filter. "
    "We currently don't allow `.txt` attachments, so here are some tips to help you travel safely: \n\n"
    "• If you attempted to send a message longer than 2000 characters, try shortening your message "
    "to fit within the character limit or use a pasting service (see below) \n\n"
    "• If you tried to show someone your code, you can use codeblocks or use a pasting service "
)

# DISALLOWED_EMBED_DESCRIPTION = (
#     "It looks like you tried to attach file type(s) that we do not allow ({blocked_extensions_str}). "
#     "We currently allow the following file types: **{joined_whitelist}**.\n\n"
#     "Feel free to ask someone if you think this is a mistake."
# )
with open("config-default.yml", encoding="UTF-8") as f:
    _CONFIG_YAML = yaml.safe_load(f)


class YAMLGetter(type):
    """
    Implements a custom metaclass used for accessing
    configuration data by simply accessing class attributes.
    Supports getting configuration from up to two levels
    of nested configuration through `section` and `subsection`.
    `section` specifies the YAML configuration section (or "key")
    in which the configuration lives, and must be set.
    `subsection` is an optional attribute specifying the section
    within the section from which configuration should be loaded.
    Example Usage:
        # config.yml
        bot:
            prefixes:
                direct_message: ''
                guild: '!'
        # config.py
        class Prefixes(metaclass=YAMLGetter):
            section = "bot"
            subsection = "prefixes"
        # Usage in Python code
        from config import Prefixes
        def get_prefix(bot, message):
            if isinstance(message.channel, PrivateChannel):
                return Prefixes.direct_message
            return Prefixes.guild
    """

    subsection = None

    def __getattr__(cls, name):
        name = name.lower()

        try:
            if cls.subsection is not None:
                return _CONFIG_YAML[cls.section][cls.subsection][name]
            return _CONFIG_YAML[cls.section][name]
        except KeyError:
            dotted_path = ".".join(
                (cls.section, cls.subsection, name)
                if cls.subsection is not None
                else (cls.section, name)
            )
            log.critical(
                f"Tried accessing configuration variable at `{dotted_path}`, but it could not be found."
            )
            raise

    def __getitem__(cls, name):
        return cls.__getattr__(name)

    def __iter__(cls):
        """Return generator of key: value pairs of current constants class' config values."""
        for name in cls.__annotations__:
            yield name, getattr(cls, name)


class Filter(metaclass=YAMLGetter):
    section = "filter"

    filter_zalgo: bool
    filter_invites: bool
    filter_domains: bool
    filter_everyone_ping: bool
    watch_regex: bool
    watch_rich_embeds: bool

    # Notifications are not expected for "watchlist" type filters
    notify_user_zalgo: bool
    notify_user_invites: bool
    notify_user_domains: bool
    notify_user_everyone_ping: bool

    ping_everyone: bool
    offensive_msg_delete_days: int

    channel_whitelist: None


class AntiMalware(Cog):
    """Delete messages which contain attachments with non-whitelisted file extensions."""

    def __init__(self, bot: Bot):
        self.bot = bot
        self.filter_list_cache = defaultdict(dict)

    def _get_whitelisted_file_formats(self) -> list:
        """Get the file formats currently on the whitelist."""
        return self.filter_list_cache["FILE_FORMAT.True"].keys()

    def _get_disallowed_extensions(self, message: Message) -> t.Iterable[str]:
        """Get an iterable containing all the disallowed extensions of attachments."""
        file_extensions = {
            splitext(attachment.filename.lower())[1]
            for attachment in message.attachments
        }
        extensions_blocked = file_extensions - set(self._get_whitelisted_file_formats())
        return extensions_blocked

    @Cog.listener()
    async def on_message(self, message: Message) -> None:
        """Identify messages with prohibited attachments."""
        # Return when message don't have attachment and don't moderate DMs
        if not message.attachments or not message.guild:
            return

        # Ignore webhook and bot messages
        if message.webhook_id or message.author.bot:
            return

        # Check if user is staff, if is, return
        # Since we only care that roles exist to iterate over, check for the attr rather than a User/Member instance

        embed = Embed()
        extensions_blocked = self._get_disallowed_extensions(message)
        blocked_extensions_str = ", ".join(extensions_blocked)
        if ".py" in extensions_blocked:
            # Short-circuit on *.py files to provide a pastebin link
            embed.description = PY_EMBED_DESCRIPTION
        # if ".txt" in extensions_blocked:
        #     # Work around Discord AutoConversion of messages longer than 2000 chars to .txt

        #     embed.description = TXT_EMBED_DESCRIPTION
        if ".exe" in extensions_blocked:
            embed.description = EXE_EMBED_DESCRIPTION
        if embed.description:
            log.info(
                f"User '{message.author}' ({message.author.id}) uploaded blacklisted file(s): {blocked_extensions_str}",
                extra={
                    "attachment_list": [
                        attachment.filename for attachment in message.attachments
                    ]
                },
            )

            await message.channel.send(f"Hey {message.author.mention}!", embed=embed)

            # Delete the offending message:
            try:
                await message.delete()
            except NotFound:
                log.info(
                    f"Tried to delete message `{message.id}`, but message could not be found."
                )


def setup(bot):
    """Load the AntiMalware cog."""
    bot.add_cog(AntiMalware(bot))
